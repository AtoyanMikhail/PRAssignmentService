// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: statistics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAssignmentStats = `-- name: GetAssignmentStats :many
SELECT 
    u.user_id,
    u.username,
    t.team_name,
    COUNT(pr.id) as total_assignments,
    COUNT(CASE WHEN p.status = 'OPEN' THEN 1 END) as open_prs,
    COUNT(CASE WHEN p.status = 'MERGED' THEN 1 END) as merged_prs
FROM users u
LEFT JOIN teams t ON u.team_id = t.id
LEFT JOIN pr_reviewers pr ON u.user_id = pr.user_id
LEFT JOIN pull_requests p ON pr.pull_request_id = p.pull_request_id
GROUP BY u.user_id, u.username, t.team_name
ORDER BY total_assignments DESC
`

type GetAssignmentStatsRow struct {
	UserID           string  `json:"user_id"`
	Username         string  `json:"username"`
	TeamName         *string `json:"team_name"`
	TotalAssignments int64   `json:"total_assignments"`
	OpenPrs          int64   `json:"open_prs"`
	MergedPrs        int64   `json:"merged_prs"`
}

// Статистика назначений по пользователям
func (q *Queries) GetAssignmentStats(ctx context.Context) ([]GetAssignmentStatsRow, error) {
	rows, err := q.db.Query(ctx, getAssignmentStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAssignmentStatsRow{}
	for rows.Next() {
		var i GetAssignmentStatsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamName,
			&i.TotalAssignments,
			&i.OpenPrs,
			&i.MergedPrs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRStats = `-- name: GetPRStats :many
SELECT 
    pr.pull_request_id,
    pr.pull_request_name,
    pr.author_id,
    pr.status,
    COUNT(r.id) as reviewers_count,
    pr.created_at,
    pr.merged_at
FROM pull_requests pr
LEFT JOIN pr_reviewers r ON pr.pull_request_id = r.pull_request_id
GROUP BY pr.pull_request_id, pr.pull_request_name, pr.author_id, pr.status, pr.created_at, pr.merged_at
ORDER BY pr.created_at DESC
`

type GetPRStatsRow struct {
	PullRequestID   string           `json:"pull_request_id"`
	PullRequestName string           `json:"pull_request_name"`
	AuthorID        string           `json:"author_id"`
	Status          string           `json:"status"`
	ReviewersCount  int64            `json:"reviewers_count"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	MergedAt        pgtype.Timestamp `json:"merged_at"`
}

// Статистика по Pull Request'ам
func (q *Queries) GetPRStats(ctx context.Context) ([]GetPRStatsRow, error) {
	rows, err := q.db.Query(ctx, getPRStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPRStatsRow{}
	for rows.Next() {
		var i GetPRStatsRow
		if err := rows.Scan(
			&i.PullRequestID,
			&i.PullRequestName,
			&i.AuthorID,
			&i.Status,
			&i.ReviewersCount,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamStats = `-- name: GetTeamStats :many
SELECT 
    t.team_name,
    COUNT(DISTINCT u.user_id) as total_members,
    COUNT(DISTINCT CASE WHEN u.is_active THEN u.user_id END) as active_members,
    COUNT(DISTINCT pr.pull_request_id) as total_prs_authored,
    COUNT(DISTINCT r.pull_request_id) as total_prs_reviewed
FROM teams t
LEFT JOIN users u ON t.id = u.team_id
LEFT JOIN pull_requests pr ON u.user_id = pr.author_id
LEFT JOIN pr_reviewers r ON u.user_id = r.user_id
GROUP BY t.team_name
ORDER BY t.team_name
`

type GetTeamStatsRow struct {
	TeamName         string `json:"team_name"`
	TotalMembers     int64  `json:"total_members"`
	ActiveMembers    int64  `json:"active_members"`
	TotalPrsAuthored int64  `json:"total_prs_authored"`
	TotalPrsReviewed int64  `json:"total_prs_reviewed"`
}

// Статистика по командам
func (q *Queries) GetTeamStats(ctx context.Context) ([]GetTeamStatsRow, error) {
	rows, err := q.db.Query(ctx, getTeamStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamStatsRow{}
	for rows.Next() {
		var i GetTeamStatsRow
		if err := rows.Scan(
			&i.TeamName,
			&i.TotalMembers,
			&i.ActiveMembers,
			&i.TotalPrsAuthored,
			&i.TotalPrsReviewed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWorkload = `-- name: GetUserWorkload :many
SELECT 
    u.user_id,
    u.username,
    t.team_name,
    u.is_active,
    COUNT(r.id) as open_reviews_count
FROM users u
LEFT JOIN teams t ON u.team_id = t.id
LEFT JOIN pr_reviewers r ON u.user_id = r.user_id
LEFT JOIN pull_requests pr ON r.pull_request_id = pr.pull_request_id AND pr.status = 'OPEN'
WHERE u.is_active = true
GROUP BY u.user_id, u.username, t.team_name, u.is_active
ORDER BY open_reviews_count DESC, u.username
`

type GetUserWorkloadRow struct {
	UserID           string  `json:"user_id"`
	Username         string  `json:"username"`
	TeamName         *string `json:"team_name"`
	IsActive         bool    `json:"is_active"`
	OpenReviewsCount int64   `json:"open_reviews_count"`
}

// Рабочая нагрузка пользователей (только открытые PR)
func (q *Queries) GetUserWorkload(ctx context.Context) ([]GetUserWorkloadRow, error) {
	rows, err := q.db.Query(ctx, getUserWorkload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWorkloadRow{}
	for rows.Next() {
		var i GetUserWorkloadRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamName,
			&i.IsActive,
			&i.OpenReviewsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
