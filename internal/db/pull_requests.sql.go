// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pull_requests.sql

package db

import (
	"context"
)

const createPullRequest = `-- name: CreatePullRequest :one
INSERT INTO pull_requests (pull_request_id, pull_request_name, author_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at
`

type CreatePullRequestParams struct {
	PullRequestID   string `json:"pull_request_id"`
	PullRequestName string `json:"pull_request_name"`
	AuthorID        string `json:"author_id"`
	Status          string `json:"status"`
}

func (q *Queries) CreatePullRequest(ctx context.Context, arg CreatePullRequestParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, createPullRequest,
		arg.PullRequestID,
		arg.PullRequestName,
		arg.AuthorID,
		arg.Status,
	)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.PullRequestID,
		&i.PullRequestName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPullRequestByID = `-- name: GetPullRequestByID :one
SELECT id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at FROM pull_requests
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPullRequestByID(ctx context.Context, id int64) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPullRequestByID, id)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.PullRequestID,
		&i.PullRequestName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPullRequestByPRID = `-- name: GetPullRequestByPRID :one
SELECT id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at FROM pull_requests
WHERE pull_request_id = $1 LIMIT 1
`

func (q *Queries) GetPullRequestByPRID(ctx context.Context, pullRequestID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPullRequestByPRID, pullRequestID)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.PullRequestID,
		&i.PullRequestName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const listPullRequests = `-- name: ListPullRequests :many
SELECT id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at FROM pull_requests
ORDER BY created_at DESC
`

func (q *Queries) ListPullRequests(ctx context.Context) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, listPullRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PullRequest{}
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.ID,
			&i.PullRequestID,
			&i.PullRequestName,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPullRequestsByStatus = `-- name: ListPullRequestsByStatus :many
SELECT id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at FROM pull_requests
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPullRequestsByStatus(ctx context.Context, status string) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, listPullRequestsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PullRequest{}
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.ID,
			&i.PullRequestID,
			&i.PullRequestName,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergePullRequest = `-- name: MergePullRequest :one
UPDATE pull_requests
SET status = 'MERGED', merged_at = COALESCE(merged_at, NOW())
WHERE pull_request_id = $1
RETURNING id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at
`

func (q *Queries) MergePullRequest(ctx context.Context, pullRequestID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, mergePullRequest, pullRequestID)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.PullRequestID,
		&i.PullRequestName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const pullRequestExists = `-- name: PullRequestExists :one
SELECT EXISTS(SELECT 1 FROM pull_requests WHERE pull_request_id = $1)
`

func (q *Queries) PullRequestExists(ctx context.Context, pullRequestID string) (bool, error) {
	row := q.db.QueryRow(ctx, pullRequestExists, pullRequestID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updatePullRequestStatus = `-- name: UpdatePullRequestStatus :one
UPDATE pull_requests
SET status = $2, merged_at = CASE WHEN $2 = 'MERGED' THEN NOW() ELSE merged_at END
WHERE pull_request_id = $1
RETURNING id, pull_request_id, pull_request_name, author_id, status, created_at, merged_at
`

type UpdatePullRequestStatusParams struct {
	PullRequestID string `json:"pull_request_id"`
	Status        string `json:"status"`
}

func (q *Queries) UpdatePullRequestStatus(ctx context.Context, arg UpdatePullRequestStatusParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, updatePullRequestStatus, arg.PullRequestID, arg.Status)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.PullRequestID,
		&i.PullRequestName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}
